<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Prescriptris â€“ Pharmacy Tetris Puzzle Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
        content="Prescriptris is a free browser game that mashes up classic Tetris with retro-pixel pharmacy fun. Stack pills, fill prescriptions, and bottle perfect squares for mega bonuses! Play this pharmacy puzzle game now." />
  <meta name="keywords"
        content="pharmacy game, tetris, tetris clone, pill stacking, prescription puzzle, retro game, pharmacy puzzle, bottle bonus, browser game, free tetris, pharmacist, medicine game, pixel art, arcade puzzle" />
  <meta property="og:title" content="Prescriptris â€“ Retro Pharmacy Tetris Puzzle Game">
  <meta property="og:description" content="Stack pills into bottles in this free browser Tetris puzzle! Fill prescriptions and earn bonuses in a retro pharmacy setting.">
  <meta property="og:type" content="game">
  <meta property="og:image" content="assets/sprites/logo.png">
  <meta property="og:url" content="https://yourdomain.com/prescriptris">
  <link rel="canonical" href="https://yourdomain.com/prescriptris" />
  <style>
    html, body { 
      margin:0; 
      height:100%; 
      overflow:hidden; 
      background:#202028; /* Dark grey retro arcade background */
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Courier New', monospace; 
    }
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 100%; 
      max-height: 100%;
      box-shadow: none;
      overflow: hidden;
      background: #000;
    }
    
    /* CRT Scanline & Screen Curvature Effect */
    .scanlines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(18, 16, 16, 0) 50%,
        rgba(0, 0, 0, 0.25) 50%
      );
      background-size: 100% 4px; /* Scanline spacing */
      pointer-events: none;
      z-index: 10;
    }
    .scanlines::after {
      content: " ";
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,0,0,0.4) 100%);
      pointer-events: none;
    }

    canvas { 
      display:block; 
      width:100%; 
      height:100%; 
      image-rendering:pixelated; 
      background: radial-gradient(circle, #2a2a2a 0%, #050505 100%);
    }
    .seo-text { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
  </style>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6JM3C1R6B9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-6JM3C1R6B9');
  </script>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <!-- CRT Overlay -->
    <div class="scanlines"></div>

    <!-- SEO Content for Pharmacy Tetris Game -->
    <div class="seo-text">
      <h1>Prescriptris: The Pharmacy Tetris Game</h1>
      <p>Play the best retro pharmacy puzzle game. Stack pills, fill prescriptions, and become a master pharmacist.</p>
      <h2>How to Play</h2>
      <ul>
        <li>Use arrow keys to move and rotate pill blocks.</li>
        <li>Create full horizontal lines to fill prescriptions.</li>
        <li>Group pills into 2x2 or larger squares for bottle bonuses!</li>
        <li>Don't let the pills stack to the top!</li>
      </ul>
    </div>
  </div>
  <script>
    // --- Globals & dynamic sizing vars ---
    let canvas, ctx;
    let CANVAS_W, CANVAS_H, GRID_SIZE;
    const COLS = 10, ROWS = 20;
    const PREVIEW_SIZE = 4, TEXT_GAP = 6, UI_PAD = 10;

    // Sprite / state globals
    let pillSheets = [], bottleImg, bgWell, bgFull;
    let locked = {};     // key="y,x" -> {frames:[...], offset}
    let current, nextPiece;
    let fallSpeed = 270, lastFall = 0;
    let score = 0, highScore = 0;
    let level = 1, linesClearedTotal = 0;
    let gameOver = false;
    let holdPiece = null;
    let holdUsed  = false;    
    let bottleFlashRegions = [];
    let bottleFlashUntil = 0;
    
    // --- Audio System ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playRetroSound(type) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      
      const now = audioCtx.currentTime;
      switch(type) {
        case 'move':
          osc.type = 'square';
          osc.frequency.setValueAtTime(220, now);
          osc.frequency.exponentialRampToValueAtTime(110, now + 0.05);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
          osc.start(now);
          osc.stop(now + 0.05);
          break;
        case 'rotate':
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(440, now);
          osc.frequency.linearRampToValueAtTime(880, now + 0.05);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.linearRampToValueAtTime(0.01, now + 0.05);
          osc.start(now);
          osc.stop(now + 0.05);
          break;
        case 'drop':
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(150, now);
          osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
          gain.gain.setValueAtTime(0.2, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          osc.start(now);
          osc.stop(now + 0.1);
          break;
        case 'lock':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(200, now);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); 
          osc.start(now);
          osc.stop(now + 0.1);
          break;
        case 'clear':
          osc.type = 'square';
          osc.frequency.setValueAtTime(440, now);
          osc.frequency.setValueAtTime(880, now + 0.1);
          gain.gain.setValueAtTime(0.2, now);
          gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
          osc.start(now);
          osc.stop(now + 0.3);
          break;
        case 'bottle':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(600, now);
          osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
          gain.gain.setValueAtTime(0.3, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
          osc.start(now);
          osc.stop(now + 0.3);
          break;
      }
    }

    // --- Particle System ---
    let particles = [];
    class Particle {
      constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4 - 2;
        this.life = 1.0;
        this.color = color;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // gravity
        this.life -= 0.02;
      }
      draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 4, 4);
        ctx.globalAlpha = 1.0;
      }
    }

    //logoIm = logo;

    // --- Handle resizing ---
    function resizeCanvas() {
      // Fit to window exactly
      CANVAS_W = window.innerWidth;
      CANVAS_H = window.innerHeight;
      canvas.width  = CANVAS_W;
      canvas.height = CANVAS_H;
      
      // Calculate responsive grid size
      // We need room for:
      // - Grid (10 cols wide)
      // - Left UI (~6-8 equivalent cols)
      // - Right UI (~6-8 equivalent cols)
      // - Top/Bottom margins (~5 rows)
      
      const totalGameCols = COLS + 14; // Grid + minimal UI space
      const totalGameRows = ROWS + 4;  // Grid + minimal vertical margin
      
      GRID_SIZE = Math.floor(
        Math.min(
          CANVAS_W / totalGameCols,
          CANVAS_H / totalGameRows
        )
      );
    }
    window.addEventListener('resize', resizeCanvas);


    function updateLevel() {
      level = Math.floor(linesClearedTotal / 10) + 1; // Level up every 10 lines
      // Speed formula: starts at ~270ms, drops by ~15ms per level, minimum 80ms
      fallSpeed = Math.max(80, 270 - (level - 1) * 15);
    }

    // --- Image loader ---
    function loadImage(src) {
      return new Promise(res => {
        const img = new Image();
        img.onload = () => res(img);
        img.src = src;
      });
    }

    // --- Tetromino shapes (5Ã—5 bitmaps) ---
    const SHAPES = [
      [ ['.....','.....','OOOO.','.....','.....'], ['..O..','..O..','..O..','..O..','.....'] ],
      [ ['.....','.....','.OOO.','..O..','.....'], ['..O..','.OO..','..O..','.....','.....'], ['.....','..O..','.OOO.','.....','.....'], ['..O..','..OO.','..O..','.....','.....'] ],
      [ ['.....','.....','.OO..','..OO.','.....'], ['..O..','.OO..','.O...','.....','.....'] ],
      [ ['.....','.....','..OO.','.OO..','.....'], ['.O...','.OO..','..O..','.....','.....'] ],
      [ ['.....','.....','.OO..','.OO..','.....'] ],
      [ ['..O..','..O..','..OO.','.....','.....'], ['.....','.OOO.','.O...','.....','.....'], ['.OO..','..O..','..O..','.....','.....'], ['...O.','.OOO.','.....','.....','.....'] ],
      [ ['..O..','..O..','.OO..','.....','.....'], ['.O...','.OOO.','.....','.....','.....'], ['..OO.','..O..','..O..','.....','.....'], ['.OOO.','...O.','.....','.....','.....'] ]
    ];

    // --- Tetromino class ---
    class Tetromino {
      constructor(x,y,shape){
        this.x=x; this.y=y; this.shape=shape; this.rot=0;
        const sheet = pillSheets[Math.floor(Math.random()*pillSheets.length)];
        this.frames=sheet;
        this.offset=Math.floor(Math.random()*sheet.length);
      }
      get format(){ return SHAPES[this.shape][this.rot % SHAPES[this.shape].length]; }
      get cells(){
        const out=[];
        this.format.forEach((row,i)=> row.split('').forEach((c,j)=> c==='O' && out.push([this.x+j,this.y+i])));
        return out;
      }
      currentFrame(){ return (Math.floor(performance.now()/250)+this.offset)%this.frames.length; }
      get sprite(){ return this.frames[this.currentFrame()]; }
    }

    // --- Game helpers ---
    function randPiece(){ return new Tetromino(Math.floor(COLS/2)-2,0,Math.floor(Math.random()*SHAPES.length)); }
    function valid(cells){ return cells.every(([x,y])=> x>=0&&x<COLS&&y<ROWS&&(y<0||!(`${y},${x}` in locked))); }
    function drawGhost(gx, gy) {
      // figure out how far the piece would drop
      let dropY = current.y;
      while (true) {
        const canDrop = current.format.every((row, i) =>
          row.split('').every((c, j) => {
            if (c !== 'O') return true;
            const x = current.x + j;
            const y = dropY + i + 1;
            return (
              x >= 0 &&
              x < COLS &&
              (y < 0 || (y < ROWS && !(locked[`${y},${x}`])))
            );
          })
        );
        if (canDrop) dropY++;
        else break;
      }

      // draw semiâ€transparent pill sprites at dropY
      ctx.save();
      ctx.globalAlpha = 0.3;
      const frameIdx = (Math.floor(performance.now()/250) + current.offset) % current.frames.length;
      const ghostImg = current.frames[frameIdx];
      current.format.forEach((row, i) => {
        row.split('').forEach((c, j) => {
          if (c === 'O') {
            const x = current.x + j;
            const y = dropY + i;
            if (y >= 0) {
              ctx.drawImage(
                ghostImg, 
                0, 0, ghostImg.width, ghostImg.height,
                gx + x * GRID_SIZE, 
                gy + y * GRID_SIZE,
                GRID_SIZE, GRID_SIZE
              );
            }
          }
        });
      });
      ctx.restore();
    }

// 1) Replace your existing clearRows() with this:
    function clearRows() {
      const fullRows = [];
      // find all full rows
      for (let y = ROWS - 1; y >= 0; y--) {
        let isFull = true;
        for (let x = 0; x < COLS; x++) {
          if (!locked[`${y},${x}`]) {
            isFull = false;
            break;
          }
        }
        if (isFull) fullRows.push(y);
      }

      if (fullRows.length === 0) return 0;

      // for each full row, delete it and shift above rows down
      fullRows.forEach(rowY => {
        // remove that row
        for (let x = 0; x < COLS; x++) {
          delete locked[`${rowY},${x}`];
        }
        // shift everything above down by 1
        // we must process keys from topâ†’bottom to avoid collision
        Object.keys(locked)
              .map(k => k.split(',').map(Number))
              .sort((a, b) => a[0] - b[0])
              .forEach(([y, x]) => {
                if (y < rowY) {
                  const val = locked[`${y},${x}`];
                  delete locked[`${y},${x}`];
                  locked[`${y+1},${x}`] = val;
                }
              });
      });

      return fullRows.length;
    }

    function clearSquares() {
      let bonus = 0, regs = [];
      // Only clear regions where all pills share the same sprite sheet
      for (let size = 4; size >= 2; size--) {
        for (let y = 0; y <= ROWS - size; y++) {
          for (let x = 0; x <= COLS - size; x++) {
            // Determine first cell's frame group
            const firstKey = `${y},${x}`;
            if (!(firstKey in locked)) continue;
            const targetFrames = locked[firstKey].frames;
            let match = true;
            // Check every cell in region
            for (let dy = 0; dy < size && match; dy++) {
              for (let dx = 0; dx < size; dx++) {
                const key = `${y+dy},${x+dx}`;
                if (!(key in locked) || locked[key].frames !== targetFrames) {
                  match = false;
                  break;
                }
              }
            }
            if (match) {
              regs.push({x, y, size});
              bonus += size * size * 5;
              // Remove matched locked cells
              for (let dy = 0; dy < size; dy++) {
                for (let dx = 0; dx < size; dx++) {
                  delete locked[`${y+dy},${x+dx}`];
                }
              }
            }
          }
        }
      }
      score += bonus;
      return regs;
    }

    // after you do: highScore = Math.max(highScore, score);
    if (score > highScore) {
      highScore = score;
      // ðŸ’¾ WRITE IT BACK so it persists across reloads
      localStorage.setItem('prescriptris_high', highScore);
    }
    // --- Restart logic ---
    function restartGame(){ 
      locked={}; 
      lastFall=performance.now(); 
      current=randPiece(); 
      nextPiece=randPiece(); 
      holdPiece = null;
      holdUsed = false;
      score=0; 
      level=1;
      linesClearedTotal=0;
      updateLevel(); // reset speed
      gameOver=false; 
      requestAnimationFrame(loop); 
    }

    // 1A) Spawn next piece, reset hold & check game-over
    function spawnNextPiece() {
      // If we swapped from hold and hold was empty before, current is now null/undefined
      // But in the hold logic we manually set current = nextPiece if holding first time.
      // Standard spawn:
      current   = nextPiece;
      nextPiece = randPiece();
      holdUsed  = false;
      highScore = Math.max(highScore, score);
      // Valid check needs to happen at spawn point (top middle)
      current.x = Math.floor(COLS/2)-2;
      current.y = 0;
      if (!valid(current.cells)) gameOver = true;
    }

    // 1B) Lock the current piece, clear lines & squares, then spawn
    function lockAndClear(gx, gy) {
      // â€” lock into `locked`
      current.cells.forEach(([x,y]) => {
        if (y >= 0) locked[`${y},${x}`] = {
          frames: current.frames,
          offset: current.offset
        };
      });

      // â€” clear horizontal rows
      const rows = clearRows();
      if (rows > 0) {
        if(audioCtx.state === 'running') playRetroSound('clear');
        linesClearedTotal += rows;
        score += rows * 100 * level; 
        updateLevel();
      }

      // â€” clear 2Ã—2+ â€œbottlesâ€
      const regions = clearSquares();
      if (regions.length > 0) {
        // Bonus for bottles based on level
        regions.forEach(r => {
          score += r.size * r.size * 50 * level;
          if(audioCtx.state === 'running') playRetroSound('bottle');
          // Add particles
          for(let i=0; i<20; i++) {
            particles.push(new Particle(gx + r.x * GRID_SIZE + Math.random() * r.size * GRID_SIZE, gy + r.y * GRID_SIZE + Math.random() * r.size * GRID_SIZE, "#ffff00"));
          }
        });
      }

      if (regions.length || rows > 0) {
        // trigger bottle flash for 300ms, but do not pause
        bottleFlashRegions = regions;
        bottleFlashUntil = performance.now() + 300;

        // Trigger pharmacist celebration animation
        pharmAnimMode = "celebrate";
        pharmAnimStart = performance.now();
        pharmAnimIdx = 0;
      }

      // always spawn next piece immediately
      spawnNextPiece();
    }
        // --- Main loop ---
    function loop(ts) {
      // 0) Ensure canvas + GRID_SIZE up to date
      resizeCanvas();
      // 1) Full-screen background
      ctx.drawImage(bgFull, 0, 0, CANVAS_W, CANVAS_H);

      //if (paused) {
        // Optionally, you can still draw locked pieces and UI, but skip current piece and input
      //  Object.entries(locked).forEach(([key,val]) => {
      //   const [y,x] = key.split(",").map(Number);
      //    const f      = (Math.floor(performance.now()/250) + val.offset) % val.frames.length;
      //    const img    = val.frames[f];
      //    ctx.drawImage(
      //      img, 0,0,img.width,img.height,
      //     gx + x*GRID_SIZE, gy + y*GRID_SIZE,
      //      GRID_SIZE, GRID_SIZE
      //    );
      //  });
        // Draw overlays/UI as needed...
      //  requestAnimationFrame(loop);
      //  return;
      //}

      // 2) Compute grid origin & size
      const gridW = COLS * GRID_SIZE,
            gridH = ROWS * GRID_SIZE,
            gx    = (CANVAS_W - gridW) / 2 | 0,
            gy    = (CANVAS_H - gridH) / 2 + 20 | 0;

      // 3) Draw well background
      ctx.drawImage(bgWell, gx, gy, gridW, gridH);
    // 3.5) --- GHOST PIECE PREVIEW ---
      drawGhost(gx, gy);

      // 3.6) --- HOLD SLOT DRAWING ---
      const holdW = PREVIEW_SIZE * GRID_SIZE + UI_PAD * 2;
      const holdH = Math.floor(holdW * 0.7); // Significantly reduced height

      // Draw Hold Panel (Top Left)
      ctx.fillStyle   = "rgba(0, 40, 0, 0.8)";
      ctx.strokeStyle = "#eee";
      ctx.lineWidth   = 3;
      // Position above Score
      const holdY = gy;
      const holdX = (gx / 2) | 0; // Same X as other UI
      
      ctx.fillRect(holdX, holdY, holdW, holdH);
      ctx.strokeRect(holdX, holdY, holdW, holdH);
      
      ctx.fillStyle = "#bbb";
      ctx.font = "16px 'Courier New', monospace";
      ctx.fillText("HOLD", holdX + 15, holdY + 20); // Moved text up
      
      if (holdPiece) {
        const psx = holdX + (holdW - PREVIEW_SIZE * GRID_SIZE) / 2;
        const psy = holdY + 25; // Adjusted piece position
        // Check if holdPiece.format is defined, otherwise fallback
        const format = holdPiece.format || SHAPES[holdPiece.shape][holdPiece.rot % SHAPES[holdPiece.shape].length];
        
        // Draw the held piece
        format.forEach((row, i) => {
          row.split('').forEach((c, j) => {
            if (c === 'O') {
              const img = holdPiece.sprite || holdPiece.frames[0]; // fallback
              ctx.drawImage(img, 
                0, 0, img.width, img.height,
                psx + j * GRID_SIZE, 
                psy + i * GRID_SIZE, 
                GRID_SIZE, GRID_SIZE
              );
            }
          });
        });
      }


      // 4) Draw logo above grid
      if (logoImg) {
        const targetW = gridW,
              aspect  = logoImg.height / logoImg.width,
              targetH = targetW * aspect,
              logoX   = (CANVAS_W - targetW) / 2,
              logoY   = gy - targetH - 20;
        ctx.drawImage(logoImg, logoX, logoY, targetW, targetH);
      }

      // 5) Leftâ€side UI panels (Score / High Score)
      // --- HOLD SLOT DRAWING ---
      //const hx = 20, hy = 20;
      const boxW = GRID_SIZE * PREVIEW_SIZE + UI_PAD * 2;
      const boxH = GRID_SIZE * PREVIEW_SIZE + UI_PAD * 3 + 20;  // +20 for â€œHOLDâ€ text

      // background & border


      // 6) Nextâ€piece box + cheat sheet
      
// 1) Compute a single uniform width for all left-side boxes
      ctx.font = "20px monospace";
      const scoreText   = `Score: ${score}`;
      const highText    = `High Score: ${highScore}`;
      const nextLabel   = "Next Pills:";
      const wScore      = ctx.measureText(scoreText).width;
      const wHigh       = ctx.measureText(highText).width;
      const wNextLabel  = ctx.measureText(nextLabel).width;
      const wPreview    = PREVIEW_SIZE * GRID_SIZE;
      // cheat sheet lines (14px font)
      const cheatLines  = [
        "â† Move Left    â†’ Move Right",
        "â†“ Soft Drop    â†‘ Rotate",
        "Space bar = Instant fall",
        "Any Key = Restart"
      ];
      ctx.font = "14px monospace";
      const wCheat = Math.max(...cheatLines.map(l => ctx.measureText(l).width));
      // the box width is the max of all these plus padding
      const leftBoxWidth = Math.max(wScore, wHigh, wNextLabel, wPreview, wCheat) + UI_PAD * 2;

      // 2) Draw Score & High Score panels
      const uiX = (gx / 2) | 0; // Align with Hold panel
      // Start below the Hold panel
      const holdW_ = PREVIEW_SIZE * GRID_SIZE + UI_PAD * 2;
      const holdH_ = Math.floor(holdW_ * 0.7); // Matches reduced height above
      let ly    = gy + holdH_ + 10; // Reduced gap

      function drawRetroPanel(lbl, val, h=60) { // Reduced panel height default
        // Drop shadow
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(uiX+4, ly+4, leftBoxWidth, h);
        
        // Main box
        ctx.fillStyle   = "rgba(0, 40, 0, 0.8)"; // Prescription bottle dark green
        ctx.strokeStyle = "#eee";
        ctx.lineWidth   = 3;
        ctx.fillRect(uiX, ly, leftBoxWidth, h);
        ctx.strokeRect(uiX, ly, leftBoxWidth, h);
        
        // Label
        ctx.font = "16px 'Courier New', monospace";
        ctx.fillStyle = "#bbb";
        ctx.fillText(lbl, uiX + 15, ly + 22);
        
        // Value
        ctx.font = "bold 20px 'Courier New', monospace";
        ctx.fillStyle = "#0f0"; // Retro Green terminal text
        // Right align value
        const valStr = "" + val;
        const valW = ctx.measureText(valStr).width;
        ctx.fillText(valStr, uiX + leftBoxWidth - valW - 15, ly + 48);
        
        ly += h + 8; // Reduced gap between panels
      }

      drawRetroPanel("SCORE", score);
      drawRetroPanel("HIGH", highScore);
      drawRetroPanel("LEVEL", level); // New Level Panel

      // 3) Draw Next-Pills preview in its own uniform box
      ctx.font = "20px monospace";
      const lh = 20;
      const bh = lh + TEXT_GAP + PREVIEW_SIZE * GRID_SIZE + UI_PAD * 2;
      
      // Background for Next Piece
      ctx.fillStyle   = "rgba(0, 40, 0, 0.8)";
      ctx.strokeStyle = "#eee";
      ctx.lineWidth   = 3;
      ctx.fillRect(uiX, ly, leftBoxWidth, bh);
      ctx.strokeRect(uiX, ly, leftBoxWidth, bh);
      
      ctx.fillStyle = "#eee";
      ctx.font = "16px 'Courier New', monospace";
      ctx.fillText(nextLabel, uiX + 15, ly + 20);

      // center the 4Ã—4 sprite grid under the label
      const psx = uiX + (leftBoxWidth - PREVIEW_SIZE * GRID_SIZE) / 2;
      const psy = ly + lh + TEXT_GAP;
      nextPiece.cells.forEach(([cx, cy]) => {
        const img = nextPiece.sprite;
        ctx.drawImage(
          img, 0, 0, img.width, img.height,
          psx + (cx - nextPiece.x) * GRID_SIZE,
          psy + (cx - nextPiece.x) / 2 + (cy - nextPiece.y) * GRID_SIZE, // Slight adjustment if needed, usually fine
          GRID_SIZE, GRID_SIZE
        );
      });
      ly += bh + 8;

      // 4) Draw the Cheat-Sheet box immediately below, same width
      ctx.font = "12px monospace";
      const cLineH = 14; 
      const cGap = 5;
      
      const cheatY     = ly + cGap;
      const cheatH     = cheatLines.length * cLineH + UI_PAD * 2;
      
      // Retro Cheat Sheet Styling
      ctx.fillStyle   = "rgba(0, 40, 0, 0.8)";
      ctx.strokeStyle = "#eee";
      ctx.lineWidth   = 3;
      ctx.fillRect(uiX, cheatY, leftBoxWidth, cheatH);
      ctx.strokeRect(uiX, cheatY, leftBoxWidth, cheatH);
      
      cheatLines.forEach((line, i) => {
        const textY = cheatY + UI_PAD + (i + 0.5) * cLineH;
        ctx.fillStyle = "#bbb"; 
        ctx.fillText(line, uiX + UI_PAD, textY);
      });
      ly = cheatY + cheatH + cGap;

      const px = uiX;
      // Pharmacist Logic: Ensure full visibility of the animation
      const pharmImg = getPharmFrame();
      const pharmW = leftBoxWidth; 
      const pharmH = (pharmImg.height / pharmImg.width) * pharmW;
      
      let py = ly + 5;
      
      // If he goes off screen, clamp him to bottom edge (with margin)
      // canvasH is available as CANVAS_H
      if (py + pharmH > CANVAS_H) {
         py = CANVAS_H - pharmH - 10; 
      }
      
      ctx.drawImage(
        pharmImg, 0, 0, pharmImg.width, pharmImg.height,
        px, py,
        pharmW, pharmH
      );

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      // 7) Right-side instructions panel (responsive font)
      // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      const margin = 20;
      const rightX = gx + gridW + margin;
      const rightW = CANVAS_W - rightX - margin;

      // draw panel background & border (unchanged)
      ctx.fillStyle   = "rgba(240,248,255,0.9)";
      ctx.strokeStyle = "black";
      ctx.lineWidth   = 2;
      ctx.fillRect(rightX, gy, rightW, gridH + 20);
      ctx.strokeRect(rightX, gy, rightW, gridH + 20);

      //  â€”â€”â€”â€”â€”â€”â€”â€” compute a responsive font size â€”â€”â€”â€”â€”â€”â€”â€”
      // Scale font based on GRID_SIZE, but allow it to grow larger on big screens
      let guideFontSize = Math.floor(GRID_SIZE * 0.45);
      // Clamp between 10px and 24px for the "handwritten" note look
      guideFontSize = Math.max(10, Math.min(guideFontSize, 24));
      
      // Use a "Handwritten" style font stack
      ctx.font      = `${guideFontSize}px 'Segoe Print', 'Comic Sans MS', cursive`;
      ctx.fillStyle = "#222255"; // Ink blue color for text

      // Rx Header
      const rxHeaderH = 50;
      ctx.fillStyle = "#3366cc";
      ctx.font = `bold ${guideFontSize * 2}px serif`;
      ctx.fillText("Rx", rightX + 15, gy + rxHeaderH - 10);
      
      ctx.fillStyle = "#444";
      ctx.font = `bold ${guideFontSize}px monospace`;
      ctx.fillText("DR. HOUSE", rightX + 70, gy + 30);
      
      // Blue divider line
      ctx.beginPath();
      ctx.strokeStyle = "#3366cc";
      ctx.lineWidth = 2;
      ctx.moveTo(rightX + 10, gy + rxHeaderH);
      ctx.lineTo(rightX + rightW - 10, gy + rxHeaderH);
      ctx.stroke();

      // your guide text lines (simulated handwriting)
      const guide = [
        "PATIENT: User #1",
        "DATE: " + new Date().toLocaleDateString(),
        "",
        "PRESCRIPTION:",
        "1. Stack pills correctly.",
        "2. Clear lines for health.",
        "3. Make 2x2 squares for",
        "   extra potency (Bonus!).",
        "",
        "WARNING:",
        "- May cause addiction.",
        "- Avoid stacking too high.",
        "",
        "REFILLS: Unlimited",
        "",
        "SIGNED: Dr. Tetris"
      ];

      let textY = gy + rxHeaderH + 10 + guideFontSize;
      const guideLineHeight = guideFontSize * 1.5;

      // Draw faint blue rules (lined paper)
      ctx.strokeStyle = "rgba(0, 0, 255, 0.1)";
      ctx.lineWidth = 1;

      // draw each line left-aligned in the panel
      ctx.font = `${guideFontSize}px 'Segoe Print', 'Comic Sans MS', cursive`;
      ctx.fillStyle = "#222255"; // Ink Blue
      
      guide.forEach(line => {
        // Draw rule line first
        ctx.beginPath();
        ctx.moveTo(rightX + 5, textY + 5);
        ctx.lineTo(rightX + rightW - 5, textY + 5);
        ctx.stroke();
        
        ctx.fillText(line, rightX + 15, textY);
        textY += guideLineHeight;
      });
      // 8) Autoâ€fall & locking + bottleâ€flash as before
      if (!gameOver && ts - lastFall > fallSpeed) {
  lastFall = ts;
  current.y++;
  if (!valid(current.cells) && current.y > 0) {
    current.y--;
    lockAndClear(gx, gy);
    requestAnimationFrame(loop);
    return;
  }
}

      // 9) Draw locked & current pieces
      Object.entries(locked).forEach(([key,val]) => {
        const [y,x] = key.split(",").map(Number);
        const f      = (Math.floor(performance.now()/250) + val.offset) % val.frames.length;
        const img    = val.frames[f];
        ctx.drawImage(
          img, 0,0,img.width,img.height,
          gx + x*GRID_SIZE, gy + y*GRID_SIZE,
          GRID_SIZE, GRID_SIZE
        );
      });
      if (current && current.cells) {
  current.cells.forEach(([x,y]) => {
    if (y >= 0) {
      const img = current.sprite;
      ctx.drawImage(
        img, 0,0,img.width,img.height,
        gx + x*GRID_SIZE, gy + y*GRID_SIZE,
        GRID_SIZE, GRID_SIZE
      );
    }
  });
}

      // 10) Grid lines on top
      ctx.strokeStyle = "#333";
      for (let i=0; i<=COLS; i++){
        ctx.beginPath();
        ctx.moveTo(gx + i*GRID_SIZE, gy);
        ctx.lineTo(gx + i*GRID_SIZE, gy + gridH);
        ctx.stroke();
      }
      for (let j=0; j<=ROWS; j++){
        ctx.beginPath();
        ctx.moveTo(gx, gy + j*GRID_SIZE);
        ctx.lineTo(gx + gridW, gy + j*GRID_SIZE);
        ctx.stroke();
      }

      // 11) Gameâ€over overlay
      if (gameOver) {
        ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
        
        ctx.save();
        // Rotate text slightly for "Stamped" look
        ctx.translate(CANVAS_W/2, CANVAS_H/2);
        ctx.rotate(-0.2);
        
        // "Expired" Stamp Box
        ctx.strokeStyle = "#d00";
        ctx.lineWidth = 10;
        ctx.strokeRect(-200, -80, 400, 160);
        
        // "Expired" Text
        ctx.fillStyle='#d00'; 
        ctx.font='bold 80px "Courier New", monospace';
        const msg='EXPIRED'; 
        const mw=ctx.measureText(msg).width;
        ctx.fillText(msg, -mw/2, 25);
        
        ctx.restore();

        // Subtext
        ctx.fillStyle='white';
        ctx.font='20px monospace';
        const pr='Press ANY KEY for new prescription'; 
        const pw=ctx.measureText(pr).width;
        ctx.fillText(pr, (CANVAS_W-pw)/2, CANVAS_H/2 + 150);
        return;
      }


      // 12) Continue & update high score
      highScore = Math.max(highScore, score);
      localStorage.setItem('prescriptris_high', highScore);

      if (bottleFlashRegions.length && performance.now() < bottleFlashUntil) {
  bottleFlashRegions.forEach(r => {
    ctx.drawImage(
      bottleImg,
      gx + r.x * GRID_SIZE,
      gy + r.y * GRID_SIZE,
      r.size * GRID_SIZE,
      r.size * GRID_SIZE
    );
  });
} else {
  bottleFlashRegions = [];
}
    // Update and draw particles
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].life -= 0.02;
      particles[i].draw(ctx);
      if (particles[i].life <= 0) particles.splice(i, 1);
    }
      requestAnimationFrame(loop);
    }


    // --- Key handling ---
    document.addEventListener('keydown', e => {
      // Audio Activation on first keypress
      if (audioCtx.state === 'suspended') audioCtx.resume();
      
      if (gameOver) { restartGame(); return; }
      // Compute gx, gy as in loop()
      const gridW = COLS * GRID_SIZE,
            gridH = ROWS * GRID_SIZE,
            gx    = (CANVAS_W - gridW) / 2 | 0,
            gy    = (CANVAS_H - gridH) / 2 + 20 | 0;
      switch(e.key) {
        case 'ArrowLeft':
          current.x--; if (!valid(current.cells)) current.x++;
          else playRetroSound('move');
          break;
        case 'ArrowRight':
          current.x++; if (!valid(current.cells)) current.x--;
          else playRetroSound('move');
          break;
        case 'ArrowDown':
          current.y++; if (!valid(current.cells)) current.y--;
          else playRetroSound('move');
          break;
        case 'ArrowUp':
          current.rot++; if (!valid(current.cells)) current.rot--;
          else playRetroSound('rotate');
          break;
        case 'c':
        case 'Shift':
        case 'ShiftLeft':
        case 'ShiftRight':
           if (!holdUsed) {
             if (holdPiece === null) {
               holdPiece = current;
               // reset position/rotation
               holdPiece.rot = 0;
               spawnNextPiece();
             } else {
               const temp = current;
               current = holdPiece;
               holdPiece = temp;
               // reset position/rotation of swapped-in piece
               current.x = Math.floor(COLS/2)-2;
               current.y = 0;
               current.rot = 0;
               holdPiece.rot = 0;
             }
             holdUsed = true;
             playRetroSound('rotate');
           }
          break;
        case ' ':
        case 'Spacebar':
          // drive the piece straight down:
          while (true) {
            current.y++;
            if (!valid(current.cells)) {
              current.y--;
              break;
            }
          }
          playRetroSound('drop');
          // lock + clear exactly as above:
          lockAndClear(gx, gy);
          break;
      }
    });

    // --- Start ---
    async function init(){
      canvas=document.getElementById("gameCanvas"); ctx=canvas.getContext("2d"); resizeCanvas();
      const [s1,s2,s3,bottle,well,full,logo,pharmacistSheet]=await Promise.all([
        loadImage("assets/sprites/pill_uniform_transparent_1.png"),
        loadImage("assets/sprites/pill_uniform_transparent_2.png"),
        loadImage("assets/sprites/pill_uniform_transparent_3.png"),
        loadImage("assets/sprites/bottle_sprite.png"),
        loadImage("assets/sprites/background_shelves_tile.png"),
        loadImage("assets/sprites/background_pharmacy.png"),
        loadImage("assets/sprites/logo.png"),
        loadImage("assets/sprites/pharmacist.png") // <--- add this line
      ]);
      [s1,s2,s3].forEach(s=>{ const w=s.width/4,h=s.height,frames=[];
        for(let i=0;i<4;i++){ const c=document.createElement("canvas"); c.width=w; c.height=h;
          c.getContext("2d").drawImage(s,i*w,0,w,h,0,0,w,h); frames.push(c);
        }
        pillSheets.push(frames);
      });
      highScore = parseInt(localStorage.getItem('prescriptris_high')) || 0;

      bottleImg=bottle; bgWell=well; bgFull=full; logoImg = logo; restartGame();

      // Pharmacist sprite slicing (2x2 grid, left-to-right, top-to-bottom)
const PHARM_FRAMES = [];
const PHARM_ROWS = 2, PHARM_COLS = 2;
const F_W = pharmacistSheet.width / PHARM_COLS;
const F_H = pharmacistSheet.height / PHARM_ROWS;
for (let row = 0; row < PHARM_ROWS; row++) {
  for (let col = 0; col < PHARM_COLS; col++) {
    const c = document.createElement("canvas");
    c.width = F_W;
    c.height = F_H;
    c.getContext("2d").drawImage(
      pharmacistSheet,
      col * F_W, row * F_H, F_W, F_H,
      0, 0, F_W, F_H
    );
    PHARM_FRAMES.push(c);
  }
}
window.PHARM_FRAMES = PHARM_FRAMES;
window.pharmAnimOffset = Math.floor(Math.random() * PHARM_FRAMES.length);
    }
    init();

    // --- Pharmacist Animation State ---
let pharmAnimMode = "normal"; // "normal" or "celebrate"
let pharmAnimStart = 0;
let pharmAnimIdx = 0;

// Normal and celebration frame orders
const PHARM_ANIM_NORMAL = [0, 2];
const PHARM_ANIM_CELEBRATE = [3, 1, 3];

// Animation helper
function getPharmFrame() {
  const now = performance.now();
  if (pharmAnimMode === "celebrate") {
    // Each celebration frame lasts 200ms
    const idx = Math.floor((now - pharmAnimStart) / 200);
    if (idx >= PHARM_ANIM_CELEBRATE.length) {
      pharmAnimMode = "normal";
      pharmAnimStart = now;
      pharmAnimIdx = 0;
      return PHARM_FRAMES[PHARM_ANIM_NORMAL[0]];
    }
    return PHARM_FRAMES[PHARM_ANIM_CELEBRATE[idx]];
  } else {
    // Normal: alternate every 400ms
    const idx = Math.floor(now / 400) % PHARM_ANIM_NORMAL.length;
    return PHARM_FRAMES[PHARM_ANIM_NORMAL[idx]];
  }
}
  </script>
</body>
</html>
